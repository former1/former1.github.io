<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css" rel="stylesheet">

    <title>Document</title>
</head>

<body class="bg-gradient-to-r from-pink-400 to-blue-500 ">


    
    <div class="flex  h-10  text-gray-200  fixed"> 
            <div class="flex flex-row w-screen bg-black justify-end" >
         
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#home1"> Home</a>
                    <a class="nav-item nav-link mx-3 mt-1 hover:underline"  href="info.html"> Info </a>
                   <a class="nav-item nav-link mx-3 mt-1 pr-5 hover:underline"  href="#footer"> Communication </a>
                

            </div>
    </div>



    

    <div class="grid ">

           <!--   <img class="w-32 h-32 rounded-full mx-auto" src="my_photo.jpg" alt="" width="384" height="512">   --> 
          
        <h1 class=" text-3xl text-center pt-60 h-screen" id ="home1">
            <p class="">Selamlar</p>
            <p class="text-lg pt-4 text-center">Ben Ömer Faruk Atasoy, çeşitli yazılım alanlarında kendini</br> geliştirmeye çalışan bir lise öğrencisiyim.</p>
        </h1>
    </div>

    


    





        <div class=" mx-4 my-10 p-5  rounded-xl bg-white bg-opacity-40 shadow-2xl">


            <h1 class=" mb-8 text-lg capitalize font-bold">What is Algorithm?</h1>
            <p class = "tracking-wide   ">
                In mathematics and computer science, an algorithm  is a finite sequence of well-defined, computer-implementable instructions, typically to solve a class of problems or to perform a computation. Algorithms are always unambiguous and are used as specifications for performing calculations, data processing, automated reasoning, and other tasks. <br>

                <br>As an effective method, an algorithm can be expressed within a finite amount of space and time,and in a well-defined formal languagefor calculating a function.Starting from an initial state and initial input (perhaps empty),the instructions describe a computation that, when executed, proceeds through a finitenumber of well-defined successive states, eventually producing "output"and terminating at a final ending state. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, incorporate random input. <br>

                <br> The concept of algorithm has existed since antiquity. Arithmetic algorithms, such as a division algorithm, was used by ancient Babylonian mathematicians c. 2500 BC and Egyptian mathematicians c. 1550 BC. Greek mathematicians later used algorithms in 240 BC in the sieve of Eratosthenes for finding prime numbers, and the Euclidean algorithm for finding the greatest common divisor of two numbers. Arabic mathematicians such as al-Kindi in the 9th century used cryptographic algorithms for code-breaking, based on frequency analysis. <br>

                <br> The word algorithm itself is derived from the name of the 9th-century mathematician Muḥammad ibn Mūsā al-Khwārizmī, whose nisba (identifying him as from Khwarazm) was Latinized as Algoritmi. A partial formalization of what would become the modern concept of algorithm began with attempts to solve the Entscheidungsproblem (decision problem) posed by David Hilbert in 1928. Later formalizations were framed as attempts to define "effective calculability" or "effective method". Those formalizations included the Gödel–Herbrand–Kleene recursive functions of 1930, 1934 and 1935, Alonzo Church's lambda calculus of 1936, Emil Post's Formulation 1 of 1936, and Alan Turing's Turing machines of 1936–37 and 1939.  
            </p>
        </div>  





    <div class="border-1 mx-4 my-10 p-5  rounded-xl bg-white bg-opacity-40 shadow-2xl ">

        <h1 class="mb-8 text-lg capitalize font-bold ">What is C++</h1>

        <p class = "tracking-wide  ">
            C++ is a general-purpose programming language created by Bjarne Stroustrup as an extension of the C programming language, or "C with Classes". The language has expanded significantly over time, and modern C++ now has object-oriented, generic, and functional features in addition to facilities for low-level memory manipulation. It is almost always implemented as a compiled language, and many vendors provide C++ compilers, including the Free Software Foundation, LLVM, Microsoft, Intel, Oracle, and IBM, so it is available on many platforms. <br>

            <br> C++ was designed with an orientation toward system programming and embedded, resource-constrained software and large systems, with performance, efficiency, and flexibility of use as its design highlights. C++ has also been found useful in many other contexts, with key strengths being software infrastructure and resource-constrained applications, including desktop applications, video games, servers (e.g. e-commerce, web search, or databases), and performance-critical applications (e.g. telephone switches or space probes). <br>

           <br> C++ is standardized by the International Organization for Standardization (ISO), with the latest standard version ratified and published by ISO in December 2020 as ISO/IEC 14882:2020 (informally known as C++20). The C++ programming language was initially standardized in 1998 as ISO/IEC 14882:1998, which was then amended by the C++03, C++11, C++14, and C++17 standards. The current C++20 standard supersedes these with new features and an enlarged standard library. Before the initial standardization in 1998, C++ was developed by Danish computer scientist Bjarne Stroustrup at Bell Labs since 1979 as an extension of the C language; he wanted an efficient and flexible language similar to C that also provided high-level features for program organization. Since 2012, C++ is on a three-year release schedule, with C++23 the next planned standard.    
        </p>
    </div>  



    
    <div class="border-1 mx-4 my-10 p-5  rounded-xl bg-white bg-opacity-40 shadow-2xl ">

        <h1 class="mb-8 text-lg capitalize font-bold">Why Do we usually use C++ in competitive programming ?</h1>

        <p class = " tracking-wide ">
            
            C++ is by far the the most popular language of choice for competitive programmers across the world as it is usually faster than Java and Python, and most of the resources are available in C++. C++ also has a vast library called STL(Standard Template Library) which makes life a lot easier for competitive coders. GNU/G++ is the standard compiler for C++ and C++ 14 is the latest updated version of C++ available on online judges. <br>

           <br> Python is an amazingly user friendly language as its codes are shorter and more concise than those in other languages and is especially used by most programmers in questions where there is a chance of integer overflow as python allows one to code without any limit on the integer value. The only flaw that python possesses though is of being slow. In comparison to C/C++ and Java, it is quite slow and thus on online coding platforms, the time limit for Python is usually higher than that of C++. To improve the speed of code execution for input/output intensive problems, like C++ python too has various input and output procedures. Normally one uses raw_input() (Python 2.7)/ input() (Python 3.5) to read and print to write. Though one can make use of sys.stdin and stdout.write() which are faster as compared to the normal input/output formats. For more information regarding fast i/o in python you can refer to here. <br>

           <br> Java is an Object Oriented Programming Language. It is the next most popular programming language after C/C++ in competitive coding. It too has many libraries for data structures called Collections in JAVA. It is bit slower than C/C++. Fetching input using Scanner class, many times, leads to a TLE verdict. BufferedReader can be used for faster input. For its complete usage, you can refer from here. Java has the BigInteger library to handle the numbers larger than 64-bit Integers but it is cumbersome to use and problems involving large numbers can generally be solved using some math in C++.  
        </p>
    </div>  


    <div class="grid grid-cols-1 gap-4 md:grid-cols-3  md:grid-rows-1 lg:grid-cols-3 lg:grid-rows-1">
        

        <div class = "border-2 mx-4 my-2 p-5  bg-white bg-opacity-40 rounded-xl ">
           <p class=" text-lg capitalize text-2xl font-bold"> Sorting Algorithms:</p>

           <ul>
                <li class="ml-8 mt-3 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#bubble"> Bubble Sort</a>
                </li>

                <li class="ml-8 mt-1 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#insertion"> Insertion Sort</a>
                </li>

                <li class="ml-8 mt-1 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href=""> Selection Sort</a>
                </li>

                <li class="ml-8 mt-1 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href=""> Merge Sort</a>
                </li>
           </ul>
           


        
        </div>


        
        <div class = "border-2 mx-4 my-2 p-5  bg-white bg-opacity-40 rounded-xl "> 
            <p class=" text-lg capitalize text-2xl font-bold" id="search"> Search Algorithms:</p>

            <ul>
                <li class="ml-8 mt-3 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#binary"> Binary Search</a>
                </li>

                <li class="ml-8 mt-1 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#"> Linear Search</a>
                </li>

                <li class="ml-8 mt-1 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#"> Jump Search</a>
                </li>

           </ul>
 
          
 
 
         
         </div>

         
 
        
         <div class = "border-2 mx-4 my-2 p-5  bg-white bg-opacity-40 rounded-xl ">
            <p class=" text-lg capitalize text-2xl font-bold"> Graph Algorithms:</p>
 
            <ul>
                <li class="ml-8 mt-3 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#dfs"> Depth First Search</a>
                </li>

                <li class="ml-8 mt-1 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#bfs"> Breadth-First-Search</a>
                </li>

                <li class="ml-8 mt-1 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#bf"> Bellman–Ford</a>
                </li>
                
                <li class="ml-8 mt-1 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#djikstra"> Dijkstra</a>
                </li>

                <li class="ml-8 mt-1 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#fw"> Floyd–Warshall</a>
                </li>

                <li class="ml-8 mt-1 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#kruskal"> Kruskal</a>
                </li>

                <li class="ml-8 mt-1 text-lg">
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="#prim"> Prim</a>
                </li>

            </ul>         

         </div>

        </div>





        <p class="text-lg pt-24 mt-24 mb-0 capitalize text-5xl font-bold text-center">SORTING ALGORITHMS</p>

        
        <div class=" mx-4 my-10 p-5  rounded-xl bg-white bg-opacity-40 shadow-2xl">


            <h1 class=" mb-12 text-3xl capitalize font-bold" id="bubble">Bubble Sort</h1>

            <h2 class=" mb-4 text-lg capitalize font-bold">Description of the algorithm</h2>
            <p class = "tracking-wide ">
                Although bubble sort is one of the simplest sorting algorithms to understand and implement, its O(n2) complexity means that its efficiency decreases dramatically on lists of more than a small number of elements. Even among simple O(n2) sorting algorithms, algorithms like insertion sort are usually considerably more efficient. <br>

               <br> Due to its simplicity, bubble sort is often used to introduce the concept of an algorithm, or a sorting algorithm, to introductory computer science students. However, some researchers such as Owen Astrachan have gone to great lengths to disparage bubble sort and its continued popularity in computer science education, recommending that it no longer even be taught. <br>

               <br> The Jargon File, which famously calls bogosort "the archetypical [sic] perversely awful algorithm", also calls bubble sort "the generic bad algorithm".[5] Donald Knuth, in The Art of Computer Programming, concluded that "the bubble sort seems to have nothing to recommend it, except a catchy name and the fact that it leads to some interesting theoretical problems", some of which he then discusses.
                
                
            </p>


            <h3 class=" mb-4 my-4 text-lg capitalize font-bold">Implementation</h3>
            
            <div class = "border-2 mx-4  p-5  bg-black bg-opacity-80 rounded-xl text-white">
 
                
                <pre>


void bubbleSort(int array[], int size) {

    for (int i = 0; i < (size-1); ++i) 
    {

      for (int j = 0; j < size-(i-1); ++j)
      {
  
        if (array[j] > array[j + 1]) {
            swap(array[j],array[j+1]);
        }
      }
    }
  }
                    
                </pre>

                   

                
    
             </div>

        </div>  






        <div class=" mx-4 my-10 p-5  rounded-xl bg-white bg-opacity-40 shadow-2xl">


            <h1 class=" mb-12 text-3xl capitalize font-bold" id="insertion">Insertion Sort</h1>

            <h2 class=" mb-4 text-lg capitalize font-bold">Description of the algorithm</h2>
            <p class = "tracking-wide ">
                Insertion sort iterates, consuming one input element each repetition, and grows a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. <br>

              <br>  Sorting is typically done in-place, by iterating up the array, growing the sorted list behind it. At each array-position, it checks the value there against the largest value in the sorted list (which happens to be next to it, in the previous array-position checked). If larger, it leaves the element in place and moves to the next. If smaller, it finds the correct position within the sorted list, shifts all the larger values up to make a space, and inserts into that correct position. <br> 

              <br>  The resulting array after k iterations has the property where the first k + 1 entries are sorted ("+1" because the first entry is skipped). In each iteration the first remaining entry of the input is removed, and inserted into the result at the correct position, thus extending the result becomes with each element greater than x copied to the right as it is compared against x.
                
                
            </p>


            <h3 class=" mb-4 my-4 text-lg capitalize font-bold">Implementation</h3>
            
            <div class = "border-2 mx-4  p-5  bg-black bg-opacity-80 rounded-xl text-white">

                
                <pre>


for (int i = 0; i <= data.lenght(); i++)
{
    int j=i;

    while( j> 0 and data [i] < data[j-1])
        j--;

    int temp=data[i];
    for (int k=i; k >j; k--)
    {
        data[k] =data[k-1];
    }
    data[j]= temp;

}         
                </pre>

                   
                
                
    
             </div>

             

        </div>  








        <p class="text-lg pt-24 mt-24 mb-0 capitalize text-5xl font-bold text-center">SEARCH ALGORITHMS</p>

        
        <div class=" mx-4 my-10 p-5  rounded-xl bg-white bg-opacity-40 shadow-2xl">


            <h1 class=" mb-12 text-3xl capitalize font-bold" id="binary">Binary search</h1>

            <h2 class=" mb-4 text-lg capitalize font-bold">Description of the algorithm</h2>
            <p class = "tracking-wide ">
                In computer science, binary search, also known as half-interval search, logarithmic search, or binary chop, is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half, again taking the middle element to compare to the target value, and repeating this until the target value is found. If the search ends with the remaining half being empty, the target is not in the array. <br>

               <br> Binary search runs in logarithmic time in the worst case, making O(\log n) comparisons, where n is the number of elements in the array. Binary search is faster than linear search except for small arrays. However, the array must be sorted first to be able to apply binary search. There are specialized data structures designed for fast searching, such as hash tables, that can be searched more efficiently than binary search. However, binary search can be used to solve a wider range of problems, such as finding the next-smallest or next-largest element in the array relative to the target even if it is absent from the array. <br>

               <br> There are numerous variations of binary search. In particular, fractional cascading speeds up binary searches for the same value in multiple arrays. Fractional cascading efficiently solves a number of search problems in computational geometry and in numerous other fields. Exponential search extends binary search to unbounded lists. The binary search tree and B-tree data structures are based on binary search. <br>
                
                
            </p>


            <h3 class=" mb-4 my-4 text-lg capitalize font-bold">Implementation</h3>
            
            <div class = "border-2 mx-4  p-5  bg-black bg-opacity-80 rounded-xl text-white">

                
                <pre>
int bs(int a){

    int ek=0;
    int eb=n-1;
    while(eb>=ek)
    {
        int orta =(ek+eb)/2;
        if (dizi[orta]==a){
            return orta;
        }
        if (dizi[orta] < a){
            ek = orta+1;
        }
        if (dizi[orta] > a){ 
            eb = orta-1;
        }
    }
    return -1;
}        
                </pre>

                   

                
    
             </div>

        </div>  









        <p class="text-lg pt-24 mt-24 mb-0 capitalize text-5xl font-bold text-center">GRAPH ALGORITHMS</p>


        <div class=" mx-4 my-10 p-5  rounded-xl bg-white bg-opacity-40 shadow-2xl">


            <h1 class=" mb-12 text-3xl capitalize font-bold" id="dfs" >Depth First Search</h1>

            <h2 class=" mb-4 text-lg capitalize font-bold">Description of the algorithm</h2>
            <p class = "tracking-wide ">
                Depth First Search is one of the main graph algorithms. Depth First Search finds the lexicographical first path in the graph from a source vertex u to each vertex. Depth First Search will also find the shortest paths in a tree (because there only exists one simple path), but on general graphs this is not the case. <br>

                
                <br> The algorithm works in O(m+n) time where n is the number of vertices and m is the number of edges. <br>

               <br> The idea behind DFS is to go as deep into the graph as possible, and backtrack once you are at a vertex without any unvisited adjacent vertices. <br>

               <br> It is very easy to describe / implement the algorithm recursively: We start the search at one vertex. After visiting a vertex, we further perform a DFS for each adjacent vertex that we haven't visited before. This way we visit all vertices that are reachable from the starting vertex.
            </p>


            <h3 class=" mb-4 my-4 text-lg capitalize font-bold">Implementation</h3>
            
            <div class = "border-2 mx-4  p-5  bg-black bg-opacity-80 rounded-xl text-white break-word hover:focus">

                
                <pre>
vector< vector < int > > adj;
int n;
                    
vector< bool > visited;      
    void dfs(int v) { <br> 
        visited[v] = true; 
        for (int u : adj[v]) { <br>
            if (!visited[u]) 
            dfs(u); 
            }
        }   
                </pre>

                   

                
    
             </div>

        </div>  







        <div class=" mx-4 my-10 p-5  rounded-xl bg-white bg-opacity-40 shadow-2xl">


            <h1 class=" mb-12 text-3xl capitalize font-bold" id="bfs">Breadth-first search</h1>

            <h2 class=" mb-4 text-lg capitalize font-bold">Description of the algorithm</h2>
            <p class = "tracking-wide ">
                The algorithm takes as input an unweighted graph and the id of the source vertex s. The input graph can be directed or undirected, it does not matter to the algorithm. <br>

               <br> The algorithm can be understood as a fire spreading on the graph: at the zeroth step only the source s is on fire. At each step, the fire burning at each vertex spreads to all of its neighbors. In one iteration of the algorithm, the "ring of fire" is expanded in width by one unit (hence the name of the algorithm). <br>
                
               <br> More precisely, the algorithm can be stated as follows: Create a queue q which will contain the vertices to be processed and a Boolean array used[] which indicates for each vertex, if it has been lit (or visited) or not. <br>
                
               <br> Initially, push the source s to the queue and set used[s]=true, and for all other vertices v set used[v]=false. Then, loop until the queue is empty and in each iteration, pop a vertex from the front of the queue. Iterate through all the edges going out of this vertex and if some of these edges go to vertices that are not already lit, set them on fire and place them in the queue. <br>
                
               <br> As a result, when the queue is empty, the "ring of fire" contains all vertices reachable from the source s, with each vertex reached in the shortest possible way. You can also calculate the lengths of the shortest paths (which just requires maintaining an array of path lengths d[]) as well as save information to restore all of these shortest paths (for this, it is necessary to maintain an array of "parents" p[], which stores for each vertex the vertex from which we reached it). <br>
                
                
            </p>


            <h3 class=" mb-4 my-4 text-lg capitalize font-bold">Implementation</h3>
            
            <div class = "border-2 mx-4  p-5  bg-black bg-opacity-80 rounded-xl text-white">

                
                <pre>
vector < vector< int > > adj;  
    int n; 
    int s; 
    
    queue< int > q;
    vector< bool > used(n);
    vector< int > d(n), p(n);
    
    q.push(s);
    used[s] = true;
    p[s] = -1;
    while (!q.empty()) 
    { 
        int v = q.front();
        q.pop();
        for (int u : adj[v]) 
        {
            if (!used[u]) 
            {
                used[u] = true;
                q.push(u);
                d[u] = d[v] + 1;
                p[u] = v;
            }
        }
    }
                </pre>

                   

                
    
             </div>

        </div>  




        <div class ="h-screen"></div>





        <div class="border-1 mx-4 my-10 p-5  rounded-xl bg-white bg-opacity-40 shadow-2xl ">

            <h1 class="mb-8 text-lg capitalize font-bold">Resources </h1>
    
            <p class = " tracking-wide ">

                
                
                <li>
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="https://en.wikipedia.org/wiki/Algorithm"> https://en.wikipedia.org/wiki/Algorithm</a>
                </li>

                <li>
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="https://en.wikipedia.org/wiki/C%2B%2B"> https://en.wikipedia.org/wiki/C%2B%2B</a> 
                </li>

                <li>
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="https://cses.fi/book/book.pdf"> Competitive Programmer's Handbook. A. Laaksenon April 3,2017</a> 
                </li>

                <li>
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="https://en.wikipedia.org/wiki/Bubble_sort"> https://en.wikipedia.org/wiki/Bubble_sort</a>   
                </li>

                <li>
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="https://www.programiz.com/dsa/bubble-sort"> https://www.programiz.com/dsa/bubble-sort</a>   
                </li>
                
                <li>
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="https://en.wikipedia.org/wiki/Insertion_sort"> https://en.wikipedia.org/wiki/Insertion_sort</a>   
                </li>

                <li>
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="https://en.wikipedia.org/wiki/Binary_search_algorithm"> https://en.wikipedia.org/wiki/Binary_search_algorithm</a>   
                </li>
                

                <li>
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="https://cp-algorithms.com/graph/depth-first-search.html"> https://cp-algorithms.com/graph/depth-first-search.html</a>  
                </li>

                <li>
                    <a class="nav-item nav-link mr-3 mt-1 hover:underline"  href="https://cp-algorithms.com/graph/breadth-first-search.html"> https://cp-algorithms.com/graph/breadth-first-search.html</a>  
                </li>

        


            </p>
        </div>  



            <footer class="footer bg-black relative pt-1 border-b-2 border-blue-700" id="footer">
                <div class="container mx-auto px-6">
            
                    <div class="sm:flex sm:mt-8">
                        <div class="mt-8 sm:mt-0 sm:w-full sm:px-8 flex flex-col md:flex-row justify-around">
                            <div class="flex flex-col mb-4">
                                <span class="font-bold text-gray-400 uppercase mt-4 md:mt-0 mb-2">İletİşİm</span>
                                <span class="my-2"><a href="https://mail.google.com/mail/u/0/#inbox" class="text-white text-md hover:text-blue-500">atasoyfomer@gmail.com</a></span>
                                <span class="my-2"><a href="#" class="text-white  text-md hover:text-blue-500">0507 908 4142</a></span>
                            </div>
                            <div class="flex flex-col mb-4">


                                <span class="font-bold text-gray-400 uppercase mb-2">Sosyal Medya</span>
                                <span class="my-2"><a href="https://github.com/" class="text-white  text-md hover:text-blue-500">GitHub</a></span>
                                <span class="my-2"><a href="https://twitter.com/" class="text-white text-md hover:text-blue-500">Twitter</a></span>
                                <span class="my-2"><a href="https://www.instagram.com/?hl=tr" class="text-white text-md hover:text-blue-500">Instagram</a></span>
                            </div>
                           
                        </div>
                    </div>
                </div>
                
            </footer>

            




</body>
</html>